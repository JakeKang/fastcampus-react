비동기프로그래밍의 이해
===
* 대부분 기업형 어플리케이션은 중앙의 서버에서 동작합니다.
* 이러한 서버는 Web을 위한 HTTP서버 또는 소켓통신을 위한 네트워크 서버등이 있습니다.
* 서버는 중앙집중형태로 클라이언트 요청을 받으므로 병목현상이 발생하기 쉬우며 처리성능에 주의해야합니다.

* 클라이언트 요청이 많은경우 서버는 병목구간이 발생합니다.
* 이러한 병목구간을 분석해보면 대부분 프로그램 로직보다는 입출력에서 많이 발생합니다.
* 입출력에서 소요되는 비용은 생각보다 많습니다.

* 이와같이 서버에 입출력을 처리하다가 지연이 발생하면 다른 요청들은 처리되지 못하고 계속 대기하는 현상이 발생합니다.
* 대부분의 기업형 서버 플랫폼들은 이 문제를 해결하기 위하여 사용자의 요청을 쓰레드로 처리하고 있습니다.
### 요약
* 기존의 서버는 중앙집중형태로 하나의 서버에서 요청을 받아 작업을 진행하여 요청하는 도중 병목현상이 많이 발생합니다.프로그램을 실행시켜보면 해당 로직보다는 파일 입출력에서 많은 비용이 발생하는 것을 확인할 수 있습니다.
* 서버에서 입출력을 처리하다가 요청들이 계속오면 처리되지 못하여 작업이 대기하는 현상이 발생합니다. 그래서 서버는 멀티 쓰레드를 이용하여 요청작업을 처리하고 있습니다.
---
* 멀티쓰레드 방식은 요청 처리를 쓰레드에서 처리하도록 하여 병렬 처리를 가능하도록 하는 방식입니다.
* 쓰레드 서버 CPU 자원을 시분할 형태로 나누어 가짐으로써 독립실행이 가능하며 다른 요청을 동시에 받을 수 있게합니다.
* 이러한 방식은 입출력 블락킹을 해결하는 이상적인 모델처럼 보이나 몇가지 한계도 존재합니다.

* 멀티쓰레드 기반의 서버는 일반적으로 클라이언트 요청마다 쓰레드를 발생시킵니다.
* 동시접속사의 수가 많은수록 쓰레드를 많이 생성하는 의미이기도 합니다.이는 곧 메모리 자원을 많이 소모함을 뜻하기도 합니다.
* 그러나 서버의 자원은 제한적이며 일정수 이상의 쓰레드는 발생시킬 수 없습니다.

* 멀티쓰레드는 이런 근본적인 문제를 안고 있기 때문에 현장에서 서버를 업그레이드 하거나 로드밸런싱등으로 분산처리 하는것입니다.

* 멀티쓰레드 방식은 각 쓰레드간의 공유 자원 접근시 신중해야 합니다. 각 쓰레드는 독립적인 시점에서 동작하므로 공유자원에 대한 동기화없이 접근하면 예기치 않은 결과가 나올 수 있습니다.
### 요약
* 기존에 서버의 병목현상을 해결하기 위하여 여러가지 쓰레드는 만들어 처리하는 방식으로 진행하였습니다.
* 이러한 방식은 사용자마다 쓰레드를 생성하기 때문에 다른요청을 동시에 받을수 있게 할 수 있습니다.
* 문제점은 서버자원은 한정되어 사용자가 계속 증가하면 쓰레드도 계속 증가하게 됩니다. 어느 수준 이상을 가면 그 이상의 쓰레드를 발생시킬 수 없습니다.
* 이를 해결하기 위하여 로드밸런싱이나 서버를 업그레이드 하는 방식으로 진행합니다.
* 쓰레드는 공유자원을 사용할때 신중하여야해서 쓰레드는 독립적으로 동작합니다. 이런 상황에서 동기화 없이 접근하면 예기치 않은 결과 나올 수 있습니다.
---
* 동기방식의 또다른 처리는 하나의 요청이 처리되는 동안 다른 요청이 처리되지 못하며 요청이 완료되어야만 다음처리가 가능한 방식입니다.
* 동기방식은 입출력을 블락킹하는데 지금까지 이러한 문제를 쓰레드로 처리했습니다.
* 이 문제를 비동기 방식으로 처리할 수 있습니다. 비동기 방식은 하나의 요청 처리가 완료되기 전에 제어권을 다음요청으로 넘깁니다.
* 따라서 입출력처리는 블락킹이 발생하지 않으며 다음 요청을 처리할 수 있습니다.
### 요약
* 동기방식은 하나의 요청만 처리할 수 있어서 입출력을 블락킹을 하는데 이 문제를 쓰레드로 해결했습니다.
* 다른방식으로 비동기 방식으로 처리할 수 있습니다. 비동기는 요청 처리가 완료되기 이전에 저어권을 다음 요청으로 넘깁니다.
---
* Node.js는 비동기 입출력을 지원하면 싱글 쓰레드 기반으로 동작하는 서버입니다.
* 노드 서버는 비동기 방식으로 요청을 처리하므로 요청을 처리하면서 다음요청을 받을 수 있습니다.
* 또한 병렬처리를 쓰레드로 처리하지 않으므로 멀티 쓰레드가 갖는 근원적인 문제에서 자유롭습니다.
#### node.js는 싱글쓰레드 기반으로 비동기방식으로 요청을 처리함. 멀티쓰레드가 가지는 문제에서 자유로움.
* Node.js의 비동기 처리는 이벤트 방식으로 풀어냅니다.
* 클라이언트의 요청을 비동기로 처리하기 위하여 이벤트가 발생하며 서버 내부에 메세지 형태로 전달됩니다.
* 서버 내부에서는 이 메세지를 이벤트루프가 처리합니다.
* 이벤트 루프가 처리하는 동안 제어권은 다음 요청으로 넘어가고 완료되면 콜백을 호출하려 처리완료를 호출측에 알려줍니다.
#### node는 이벤트 방식으로 해결, 비동기 처리를 위하여 이벤트가 발생을 내부에 메세지 형태로 전달, 서버 내부에서 메세지를 이벤트루프가 처리, 이벤트 루프가 처리되는 동안 제어권은 넘어가고 완료하면 콜백을 호출하려 처리완료를 알려줌.
* 이벤트 루프는 요청을 처리하기 위하여 내부적으로 약간 쓰레드와 프로세스를 사용합니다.
* 이방식은 논블록킹 입출력 또는 내부처리를 위한 목적으로만 사용되지 요청처리 자체를 쓰레드로 해결하지는 않습니다.
* 따라서 node서버는 멀티쓰레드 방식의 서버에 비하여 쓰레드수와 오버헤드가 적습니다.
#### 요청 처리를 위하여 약간의 쓰레드와 프로세스를 사용, 입출력,내부처리의 목적으로 사용, 노드서버는 쓰레드수와 오버헤드가 적음
* 이벤트를 처리하는 이벤트루프는 싱글쓰레드로 이루어져 있습니다.
* 즉 요청 처리는 하나의 쓰레드 안에서 처리된다는 의미입니다.
* 그래서 이벤트 호출측에는 비동기로 처리되지만 처리작접 자체가 오래 걸린다면 전체 서버 처리에 영향을 줍니다,.
* 이는 노드서버의 약점입니다.
#### 이벤트루프는 싱글쓰레드, 요청이 하나의 쓰레드에서 처리됌, 비동기로 처리되지만 처리가 오래걸리면 서버에 영향을주는게 단점음
### 요약
* Node.js는 싱글쓰레드 기반으로 비동기방식으로 요청을 처리하여 멀티쓰레드가 가지는 문제로부터 자유로울 수 있습니다.
* node는 이벤트 방식으로 해결하고 이벤트를 메세지 형태로 전달합니다. 서버는 내부에서 메세지를 이벤트루프가 처리하며, 이벤트 루프가 처리되는동안 제어권은 넘어가고 완료되면 콜백을 호출하여 처리완료를 알려줍니다.
* 논블록킹 입출력 또는 내부처리를 위한 목적으로만 프로세스와 쓰레드를 사용하지 요청 처리 자체를 쓰레드로 하지않습니다.
* 이벤트 루프는 싱글쓰레드로 처리하며 요청이 하나의 쓰레드에 처리됩니다. 이벤트 호출측에서는 비동기로 처리하여 처리자체가 올래걸린다면 서버에 영향을 줄 수 있습니다.
---
* Node.js는 구글크롬 V8엔진 기반으로 동작하며 내부의 이벤트 루프는 싱글쓰레드 기반에서 비동기 메세지를 처리합니다.
* 이러한 이벤트 루프는 고성능의 병렬처리를 보장하도록 설꼐되어 있습니다.
* 따라서 이벤트에 의해 처리해야 할 단위작업이 아주 짧은 시간 안에 처리된다면 Node.js의 고성능의 장점을 극대화 할 수 있습니다.
#### Node.js는 구글크롬 V8엔진 기반, 이벤트루프는 싱글쓰레드 기반에서 비동기메세지처리, 이벤트에 처리해야할 단위가 짧을수록 장점 극대화
* 만일 처리 작업이 CPU를 많이 소모한다든지 대용량 파일을 처리하는 작업이라면 Node.js는 비효율적입니다.
* IO작업이 별로없는 어플리케이션이나 단위작업이 짧은 메시징 어플리케이션의 경우에는 Node.js는 고성능을 보장.
#### CPU,대용량 파일처리할경우 Node.js는 비효율적임, IO작업이 적거나 단위작업이 짧은경우에는 Node.js는 효율적
* 한편 Node 어플리케이션 개발자가 처리 로직을 비동기로 하지 않고 동기방식으로 구성한다면 Node를 잘못 활용하는 결과를 낳을 수 있습니다.
* 따라서 Nod어플리케이션은 가능한 전부 비동기로 처리해야하며 Node개발자는 비동기 프로그래밍에 익숙해져야 할 필요성이 있습니다.
#### Node로 개별할경우에는 비동기로 처리하는것이 효율적임.
### 요약
* Node.js는 싱글쓰레드 기반에서 비동기메세지처리,이벤트에 처리해야할 단위가 짧을 수록 장점이 드러납니다. CPU,대용량파일을 처리할 경우 Node.js는 효율적이지 못합니다. 입출력 작업이 적거나 메시징 어플리케이션에서 효율적으로 사용할 수 있습니다.


* 참조 : http://www.nextree.co.kr/p7292/
* 참조 : https://brunch.co.kr/@clay1987/141